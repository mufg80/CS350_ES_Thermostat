# CS350_ES_Thermostat

This course involved programming the CC3220S board from Texas Instruments. The two projects I uploaded to this repository were a thermostat simulator and a Morse code simulator.
The Morse code generator would flash LEDs to signal the Morse code for SOS or OK, depending on the state. Toggling between the two was based on a button press.
The thermostat simulator project involved creating a prototype that could sense the temperature, increase or decrease the setpoint using buttons, turn the heat either on or off (using an LED to simulate output), and report to a server (simulated using UART to send data to the laptop through serial communication). This required the use of GPIO, UART, I2C, timers, and a state machine.
Some areas where I excelled included using bitwise operators to create the Morse code sequences and mask which turned the LED on. I also worked hard to write clean code using comments, functions, and consistent coding conventions.
There is still room for improvement. I struggled with defining the state machine and properly diagramming its specifications. Additionally, there was some inconsistency in choosing global variables versus passing in the arguments. I chose to globally declare the enumeration for the state machine’s states as well as some constants, while I passed in the server’s data structure using a pointer.
An additional tool I will use if I continue in embedded systems programming is the board manuals. Like most people, I try to find information online before diving into a several hundred-page PDF. Throughout this course, there was information that I could not find elsewhere. Once I forced myself to start reading through the technical manual, it was much faster to find the correct answer than surfing the web. I will try to take this lesson with me and apply it to other disciplines as well.
To keep this project readable and maintainable, I tried to use functions for any code that could be repeated. This helped not only to follow the rule “Don’t repeat yourself” but also to keep the code tidy and separated. Because of this, I was able to separate concerns into each function. For example, initializations, executions, interrupts, and state machine states and transitions were all moved into their own functions to create a clean and maintainable code base.
